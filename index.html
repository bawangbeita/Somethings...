<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Magical Tarot - 手势契约版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #010105; }
        /* 隐藏原始视频，只保留 3D 场景 */
        #input_video { display: none; }
        #loading-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: #02020a; display: flex; flex-direction: column;
            justify-content: center; align-items: center; z-index: 2000;
            color: #ffb7c5; font-family: "PingFang SC", sans-serif;
        }
    </style>
</head>
<body>

    <div id="loading-overlay">
        <p>正在唤醒魔法阵...</p>
        <p style="font-size: 12px; opacity: 0.6;">请确保开启摄像头权限</p>
    </div>

    <video id="input_video"></video>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>

    <script>
        // --- 1. Three.js 场景设置 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        const cardGroup = new THREE.Group();
        scene.add(cardGroup);

        let isLocked = false;
        let isPinching = false; 
        let selectedCard = null;
        let targetSpeed = 0;
        let currentSpeed = 0;
        const raycaster = new THREE.Raycaster();
        const handCoord = new THREE.Vector2(); // 用于存储手势映射坐标

        // --- 2. 粒子系统 (极小星尘 + 分层) ---
        const pCount = 300;
        const pGeometry = new THREE.BufferGeometry();
        const pPositions = new Float32Array(pCount * 3);
        const pOpacity = new Float32Array(pCount);
        const pVel = new Float32Array(pCount);

        for(let i=0; i<pCount; i++) {
            pPositions[i*3+1] = -500;
            pVel[i] = 0.005 + Math.random() * 0.015;
        }
        pGeometry.setAttribute('position', new THREE.BufferAttribute(pPositions, 3));
        const pMaterial = new THREE.PointsMaterial({
            size: 0.02, color: 0xffffff, transparent: true, blending: THREE.AdditiveBlending, depthWrite: false
        });
        const pSystem = new THREE.Points(pGeometry, pMaterial);
        scene.add(pSystem);

        function emitParticles(cardPos, cardRotation) {
            for(let i=0; i<3; i++) {
                const idx = Math.floor(Math.random() * pCount);
                if (pOpacity[idx] <= 0) {
                    const layerOffset = Math.random() > 0.8 ? 0.05 : -0.15;
                    const localOffset = new THREE.Vector3((Math.random()-0.5)*0.8, -0.7, layerOffset);
                    localOffset.applyQuaternion(cardRotation);
                    pPositions[idx*3] = cardPos.x + localOffset.x;
                    pPositions[idx*3+1] = cardPos.y + localOffset.y;
                    pPositions[idx*3+2] = cardPos.z + localOffset.z;
                    pOpacity[idx] = 1.0;
                }
            }
        }

        // --- 3. 手势逻辑集成 ---
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults((results) => {
            document.getElementById('loading-overlay').style.display = 'none';
            
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                const thumbTip = hand[4];
                const indexTip = hand[8];
                const palmCenter = hand[9];

                // A. 映射手掌 X 到旋转速度 (镜像处理: 1-palm.x)
                const mappedX = (1 - palmCenter.x);
                handCoord.x = mappedX * 2 - 1;
                handCoord.y = -(indexTip.y * 2 - 1);
                
                if (!isLocked) targetSpeed = (mappedX - 0.5) * 0.15;

                // B. 捏合检测 (计算拇指和食指距离)
                const dist = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
                
                if (dist < 0.04) { // 阈值捏合
                    if (!isPinching) {
                        isPinching = true;
                        if (!isLocked) checkAndPickup();
                        else shatterCard();
                    }
                } else {
                    isPinching = false;
                }
            } else {
                targetSpeed = 0; // 手离开画面自动刹车
            }
        });

        function checkAndPickup() {
            raycaster.setFromCamera(handCoord, camera);
            const intersects = raycaster.intersectObjects(cards);
            if (intersects.length > 0) {
                isLocked = true;
                selectedCard = intersects[0].object;
                scene.attach(selectedCard);
                gsap.to(selectedCard.position, { x: 0, y: 0, z: -2.2, duration: 1.2, ease: "expo.out" });
                gsap.to(selectedCard.scale, { x: 0.6, y: 0.6, duration: 1.2 });
                gsap.to(selectedCard.rotation, { x: 0, y: Math.PI * 2, z: 0, duration: 1.5 });
            }
        }

        function shatterCard() {
            if (!selectedCard) return;
            gsap.to(selectedCard.scale, { x: 0, y: 0, duration: 0.4, onComplete: () => {
                const a = selectedCard.userData.angle;
                selectedCard.position.set(Math.sin(a)*5.5, 0, Math.cos(a)*5.5);
                selectedCard.lookAt(0,0,0);
                selectedCard.scale.set(1, 1, 1);
                cardGroup.add(selectedCard);
                isLocked = false; selectedCard = null;
            }});
        }

        // --- 4. 其它初始化与渲染循环 ---
        const createMaterial = () => new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 } },
            vertexShader: `varying vec2 vUv; void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }`,
            fragmentShader: `
                uniform float uTime; varying vec2 vUv;
                void main() {
                    vec3 c1 = vec3(0.95, 0.8, 0.9); vec3 c2 = vec3(0.7, 0.8, 1.0);
                    float wave = sin(vUv.y * 6.0 + uTime * 2.0) * 0.5 + 0.5;
                    gl_FragColor = vec4(mix(c1, c2, wave) + smoothstep(0.48, 0.5, abs(vUv.x-0.5))*0.4, 0.8);
                }
            `, transparent: true, side: THREE.DoubleSide
        });

        const cards = [];
        for (let i = 0; i < 22; i++) {
            const card = new THREE.Mesh(new THREE.PlaneGeometry(1, 1.6), createMaterial());
            const angle = (i / 22) * Math.PI * 2;
            card.position.set(Math.sin(angle) * 5.5, 0, Math.cos(angle) * 5.5);
            card.lookAt(0, 0, 0);
            card.userData.angle = angle;
            cardGroup.add(card);
            cards.push(card);
        }
        camera.position.z = 0.1;

        const cameraCtx = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 640, height: 480
        });
        cameraCtx.start();

        function animate(time) {
            requestAnimationFrame(animate);
            const t = time * 0.001;

            if (!isLocked) {
                currentSpeed += (targetSpeed - currentSpeed) * 0.05;
                currentSpeed *= 0.95;
                cardGroup.rotation.y += currentSpeed;

                raycaster.setFromCamera(handCoord, camera);
                const intersects = raycaster.intersectObjects(cards);
                cards.forEach(card => {
                    card.material.uniforms.uTime.value = t;
                    if (intersects.length > 0 && intersects[0].object === card) {
                        gsap.to(card.position, { y: 0.4, duration: 0.3 });
                        const wp = new THREE.Vector3();
                        const wq = new THREE.Quaternion();
                        card.getWorldPosition(wp);
                        card.getWorldQuaternion(wq);
                        emitParticles(wp, wq);
                    } else {
                        gsap.to(card.position, { y: 0, duration: 0.5 });
                    }
                });
            } else if (selectedCard) selectedCard.material.uniforms.uTime.value = t;

            // 更新粒子
            for(let i=0; i<pCount; i++) {
                if(pOpacity[i] > 0) {
                    pPositions[i*3+1] += pVel[i];
                    pOpacity[i] -= 0.025;
                }
                if(pOpacity[i] <= 0) pPositions[i*3+1] = -500;
            }
            pGeometry.attributes.position.needsUpdate = true;
            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>
