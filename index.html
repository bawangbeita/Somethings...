<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Soft Magic Stellar Core</title>
  <style>
    body { margin: 0; overflow: hidden; background: #000; }
    #video-input { position: absolute; width: 0; height: 0; opacity: 0; pointer-events: none; }
    #ui-right {
      position: fixed; top: 40px; right: 40px; color: #d4af37; font-family: sans-serif; z-index: 100;
      letter-spacing: 2px; font-size: 13px; background: rgba(212, 175, 87, 0.1);
      padding: 10px 20px; border-right: 2px solid #d4af37; backdrop-filter: blur(5px);
      animation: pulse 2s infinite ease-in-out;
    }
    #loader {
      position: fixed; inset: 0; background: #000; display: flex;
      align-items: center; justify-content: center; z-index: 2000;
      color: #d4af37; font-family: serif; letter-spacing: 5px; transition: opacity 0.8s;
    }
    @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
  </style>
</head>
<body>
  <div id="loader">IGNITING...</div>
  <div id="ui-right">在镜头前抓握试试看！</div>

  <video id="video-input" autoplay playsinline></video>
  <div id="container"></div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    let scene, camera, renderer, particles = [];
    let targetRotationX = 0, targetRotationY = 0;
    let currentRotationX = 0, currentRotationY = 0;
    const smoothing = 0.08;

    // 顶部发黄的3D球体
    let topper;

    function initScene() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 50;

      renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.getElementById('container').appendChild(renderer.domElement);

      // --- 柔和光晕纹理（改为中性白，方便用颜色去染绿/红/金）---
      const canvas = document.createElement('canvas');
      canvas.width = 64;
      canvas.height = 64;
      const ctx = canvas.getContext('2d');
      const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
      grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
      grad.addColorStop(0.25, 'rgba(255, 255, 255, 0.25)');
      grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, 64, 64);
      const tex = new THREE.CanvasTexture(canvas);

      const masterGroup = new THREE.Group();
      scene.add(masterGroup);
      window.masterGroup = masterGroup;

      // ====== 圣诞树（圆锥）参数 ======
      const treeHeight = 14;     // 树高
      const baseRadius = 6.0;    // 底部半径
      const yBottom = -treeHeight * 0.5;
      const yTop = treeHeight * 0.5;

      // 顶部发黄的3D球体（确保光比其他粒子都要强）
      topper = new THREE.Mesh(
        new THREE.SphereGeometry(0.9, 24, 24),
        new THREE.MeshBasicMaterial({ color: 0xffd36a, emissive: 0xffd36a, emissiveIntensity: 1.5 }) // 发黄的光
      );
      topper.userData = {
        p1: new THREE.Vector3(0, yTop + 1.1, 0),
        p2: new THREE.Vector3(0, 18, 0)
      };
      topper.position.copy(topper.userData.p1);
      masterGroup.add(topper);

      // 生成粒子：聚拢时是“圆锥圣诞树”，张开时四散（原逻辑不变：p2 仍是外部球壳）
      for (let i = 0; i < 1500; i++) {
        const group = new THREE.Group();

        // 颜色：大部分绿色 + 少量红色 + 少量金色
        const r = Math.random();
        let c;
        if (r < 0.86) {
          // 绿色：做一点深浅变化
          const g = 0.55 + Math.random() * 0.35;
          const rr = 0.10 + Math.random() * 0.10;
          const bb = 0.10 + Math.random() * 0.12;
          c = new THREE.Color(rr, g, bb);
        } else if (r < 0.94) {
          // 红色
          c = new THREE.Color(0.95, 0.15 + Math.random() * 0.10, 0.15 + Math.random() * 0.10);
        } else {
          // 金色
          c = new THREE.Color(0.92, 0.78, 0.30);
        }

        const core = new THREE.Mesh(
          new THREE.SphereGeometry(0.035),
          new THREE.MeshBasicMaterial({ color: c })
        );

        const glow = new THREE.Sprite(
          new THREE.SpriteMaterial({
            map: tex,
            color: c,
            blending: THREE.AdditiveBlending,
            transparent: true,
            opacity: 1.0
          })
        );
        glow.scale.set(0.6, 0.6, 1);

        group.add(core, glow);

        // ====== p1：圆锥（圣诞树）分布 ======
        // y 从底到顶；半径随高度线性缩小，并加一点“层次波纹”让它更像树
        const t = Math.random(); // 0..1
        const y = yBottom + t * treeHeight;
        const yn = (y - yBottom) / treeHeight; // 0..1
        const radiusMax = baseRadius * (1 - yn);

        // 加一点层次：沿高度做轻微波纹 + 随机扰动
        const layer = 1 + 0.12 * Math.sin(yn * Math.PI * 10);
        const radius = radiusMax * layer * Math.pow(Math.random(), 0.55);

        const ang = Math.random() * Math.PI * 2;
        const x = radius * Math.cos(ang);
        const z = radius * Math.sin(ang);

        // ====== p2：原来的四散球壳（不变） ======
        const phi = Math.random() * Math.PI * 2;
        const theta = Math.acos(Math.random() * 2 - 1);
        const r2 = 12 + Math.random() * 5;

        group.userData = {
          p1: new THREE.Vector3(x, y, z),
          p2: new THREE.Vector3(
            r2 * Math.sin(theta) * Math.cos(phi),
            r2 * Math.sin(theta) * Math.sin(phi),
            r2 * Math.cos(theta)
          )
        };

        group.position.copy(group.userData.p1);
        masterGroup.add(group);
        particles.push(group);
      }
    }

    async function startAuto() {
      initScene();
      const video = document.getElementById('video-input');
      const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
      hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });

      hands.onResults(results => {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
          const lm = results.multiHandLandmarks[0];

          // 判断手掌是否张开（保持你当前的“张开触发四散”逻辑）
          const thumbDist  = Math.hypot(lm[4].x  - lm[0].x, lm[4].y  - lm[0].y);
          const indexDist  = Math.hypot(lm[8].x  - lm[5].x, lm[8].y  - lm[5].y);
          const middleDist = Math.hypot(lm[12].x - lm[9].x, lm[12].y - lm[9].y);
          const ringDist   = Math.hypot(lm[16].x - lm[13].x, lm[16].y - lm[13].y);
          const pinkyDist  = Math.hypot(lm[20].x - lm[17].x, lm[20].y - lm[17].y);

          const isHandOpen =
            thumbDist  > 0.1 &&
            indexDist  > 0.1 &&
            middleDist > 0.1 &&
            ringDist   > 0.1 &&
            pinkyDist  > 0.1;

          toggleState(isHandOpen);

          targetRotationY = (lm[0].x - 0.5) * 4;
          targetRotationX = (lm[0].y - 0.5) * 4;
        }
      });

      const cameraHelper = new Camera(video, {
        onFrame: async () => await hands.send({ image: video }),
        width: 640, height: 480
      });

      try {
        await cameraHelper.start();
        document.getElementById('loader').style.opacity = '0';
        setTimeout(() => document.getElementById('loader').style.display = 'none', 800);
        animate();
      } catch (e) {
        document.getElementById('loader').innerText = "CAMERA ERROR";
      }
    }

    let isOpened = false;
    function toggleState(open) {
      if (isOpened === open) return;
      isOpened = open;

      // 粒子四散时文字变换
      const uiRight = document.getElementById('ui-right');
      if (open) {
        uiRight.innerText = "在镜头前移动手掌试试看！";
      } else {
        uiRight.innerText = "在镜头前抓握试试看！";
      }

      // 粒子动画（四散/聚拢）
      particles.forEach((p) => {
        const target = open ? p.userData.p2 : p.userData.p1;
        gsap.to(p.position, {
          x: target.x, y: target.y, z: target.z,
          duration: open ? 0.8 : 0.6,
          ease: open ? "expo.out" : "back.in(1.2)",
          delay: Math.random() * 0.15
        });
      });

      // 顶部黄球也跟着四散/聚拢
      if (topper) {
        const t = open ? topper.userData.p2 : topper.userData.p1;
        gsap.to(topper.position, {
          x: t.x, y: t.y, z: t.z,
          duration: open ? 0.8 : 0.6,
          ease: open ? "expo.out" : "back.in(1.2)"
        });
      }
    }

    function animate() {
      requestAnimationFrame(animate);

      currentRotationX += (targetRotationX - currentRotationX) * smoothing;
      currentRotationY += (targetRotationY - currentRotationY) * smoothing;

      if (window.masterGroup) {
        window.masterGroup.rotation.x = currentRotationX;
        window.masterGroup.rotation.y = currentRotationY;

        // 不管张开还是聚拢，都慢慢顺时针自转
        window.masterGroup.rotation.z += 0.002;
      }

      renderer.render(scene, camera);
    }

    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    window.onload = startAuto;
  </script>
</body>
</html>