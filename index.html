<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Magical Tarot - 鼠标模拟调试版</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050510; cursor: none; }
        #loading {
            position: fixed; top: 20px; left: 20px; color: #ffb7c5;
            font-family: "Microsoft YaHei"; pointer-events: none;
        }
        /* 自定义魔法光点鼠标 */
        #magic-cursor {
            position: fixed; width: 20px; height: 20px;
            background: radial-gradient(circle, #fff 0%, rgba(255,182,193,0) 70%);
            border-radius: 50%; pointer-events: none; z-index: 999;
            box-shadow: 0 0 15px #fff;
        }
    </style>
</head>
<body>

    <div id="loading">调试模式：使用鼠标左右移动控制旋转，点击模拟捏合</div>
    <div id="magic-cursor"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>

    <script>
        // --- 1. 场景与相机 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // --- 2. 梦幻 Shader 材质 ---
        const cardMaterial = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 }, uHover: { value: 0 } },
            vertexShader: `
                varying vec2 vUv;
                void main() { 
                    vUv = uv; 
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); 
                }
            `,
            fragmentShader: `
                uniform float uTime;
                varying vec2 vUv;
                void main() {
                    vec3 color1 = vec3(1.0, 0.8, 0.9); // 樱花粉
                    vec3 color2 = vec3(0.7, 0.8, 1.0); // 幻影蓝
                    
                    // 流动效果
                    float f = sin(vUv.x * 4.0 + uTime * 2.0) * 0.5 + 0.5;
                    vec3 base = mix(color1, color2, f);
                    
                    // 魔法阵星点
                    float stars = pow(sin(vUv.x * 50.0) * cos(vUv.y * 50.0 + uTime), 30.0);
                    
                    // 边缘发光
                    float edge = smoothstep(0.45, 0.5, abs(vUv.x - 0.5));
                    
                    gl_FragColor = vec4(base + stars + edge * 0.5, 0.9);
                }
            `,
            transparent: true,
            side: THREE.DoubleSide
        });

        // --- 3. 生成环绕卡牌 ---
        const cards = [];
        const cardGroup = new THREE.Group();
        const radius = 5;
        for (let i = 0; i < 22; i++) {
            const geo = new THREE.PlaneGeometry(1, 1.6);
            const card = new THREE.Mesh(geo, cardMaterial.clone());
            const angle = (i / 22) * Math.PI * 2;
            card.position.set(Math.sin(angle) * radius, 0, Math.cos(angle) * radius);
            card.lookAt(0, 0, 0);
            cardGroup.add(card);
            cards.push(card);
        }
        scene.add(cardGroup);
        camera.position.z = 0.1; // 位于中心

        // --- 4. 物理交互变量 ---
        let targetSpeed = 0;
        let currentSpeed = 0;
        const mouse = new THREE.Vector2();
        const raycaster = new THREE.Raycaster();
        const cursor = document.getElementById('magic-cursor');

        // --- 5. 交互监听 ---
        window.addEventListener('mousemove', (e) => {
            // 更新 UI 鼠标
            cursor.style.left = e.clientX - 10 + 'px';
            cursor.style.top = e.clientY - 10 + 'px';

            // 映射坐标
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;

            // 左右移动产生目标转速
            targetSpeed = mouse.x * 0.15;
        });

        // 模拟捏合点击
        window.addEventListener('mousedown', () => {
            const intersects = raycaster.intersectObjects(cards);
            if (intersects.length > 0) {
                const card = intersects[0].object;
                // 模拟飞向面前旋转
                gsap.to(card.position, { x: 0, y: 0, z: -1, duration: 1, ease: "expo.out" });
                gsap.to(card.rotation, { y: Math.PI * 2, duration: 1 });
            }
        });

        // --- 6. 渲染循环 ---
        function animate(time) {
            requestAnimationFrame(animate);
            const t = time * 0.001;

            // 核心阻尼感算法
            currentSpeed += (targetSpeed - currentSpeed) * 0.05; // 缓动跟随
            currentSpeed *= 0.96; // 摩擦力模拟刹车
            cardGroup.rotation.y += currentSpeed;

            // 射线检测：悬浮效果
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(cards);
            
            cards.forEach(card => {
                card.material.uniforms.uTime.value = t;
                if (intersects.length > 0 && intersects[0].object === card) {
                    gsap.to(card.position, { y: 0.3, duration: 0.4 }); // 向上悬浮
                } else {
                    gsap.to(card.position, { y: 0, duration: 0.6 });
                }
            });

            renderer.render(scene, camera);
        }
        animate();

        // 窗口自适应
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
