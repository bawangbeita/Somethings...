<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stellar Christmas - Elite Version</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #video-input { position: absolute; width: 0; height: 0; opacity: 0; pointer-events: none; }
        #ui-right {
            position: fixed; top: 40px; right: 40px; color: #d4af37; font-family: sans-serif; z-index: 100;
            letter-spacing: 2px; font-size: 13px; background: rgba(212, 175, 87, 0.1);
            padding: 10px 20px; border-right: 2px solid #d4af37; backdrop-filter: blur(5px);
            animation: pulse 2s infinite ease-in-out;
        }
        #loader {
            position: fixed; inset: 0; background: #000; display: flex;
            align-items: center; justify-content: center; z-index: 2000;
            color: #d4af37; font-family: serif; letter-spacing: 5px; transition: opacity 0.8s;
        }
        @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
    </style>
</head>
<body>
    <div id="loader">IGNITING CHRISTMAS CORE...</div>
    <div id="ui-right">在镜头前抓握试试看！</div>

    <video id="video-input" autoplay playsinline></video>
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particles = [];
        let targetRotationX = 0, targetRotationY = 0;
        let currentRotationX = 0, currentRotationY = 0;
        const smoothing = 0.08;

        let topper;
        let snowParticles = [];

        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            // 通用发光纹理
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(0.3, 'rgba(255, 255, 255, 0.3)');
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
            const tex = new THREE.CanvasTexture(canvas);

            const masterGroup = new THREE.Group();
            scene.add(masterGroup);
            window.masterGroup = masterGroup;

            const treeHeight = 16;
            const baseRadius = 6.5;
            const yBottom = -treeHeight * 0.5;
            const yTop = treeHeight * 0.5;

            // 1. 圣诞树顶：大黄色亮粒子
            const topperMat = new THREE.SpriteMaterial({
                map: tex, color: 0xffdd44, blending: THREE.AdditiveBlending, transparent: true
            });
            topper = new THREE.Sprite(topperMat);
            topper.scale.set(3.5, 3.5, 1);
            // 紧贴树尖，不留空隙
            topper.userData = {
                p1: new THREE.Vector3(0, yTop, 0),
                p2: new THREE.Vector3(0, 0, 0)
            };
            topper.position.copy(topper.userData.p1);
            masterGroup.add(topper);

            // 2. 圣诞树身粒子
            for (let i = 0; i < 1500; i++) {
                const group = new THREE.Group();
                const r = Math.random();
                let c = (r < 0.85) ? new THREE.Color(0.1, 0.6+Math.random()*0.3, 0.2) : 
                        (r < 0.93) ? new THREE.Color(0.9, 0.2, 0.2) : new THREE.Color(0.9, 0.8, 0.3);

                const core = new THREE.Mesh(new THREE.SphereGeometry(0.035), new THREE.MeshBasicMaterial({ color: c }));
                const glow = new THREE.Sprite(new THREE.SpriteMaterial({ map: tex, color: c, blending: THREE.AdditiveBlending, transparent: true, opacity: 0.7 }));
                glow.scale.set(0.6, 0.6, 1);
                group.add(core, glow);

                // 圆锥算法优化：让顶部更尖，yn越接近1（顶部）半径收缩越快
                const t = Math.random();
                const y = yBottom + t * treeHeight;
                const yn = (y - yBottom) / treeHeight; 
                const radiusMax = baseRadius * Math.pow(1 - yn, 1.2); // 使用pow让顶部收缩更陡峭

                const ang = Math.random() * Math.PI * 2;
                const radius = radiusMax * Math.pow(Math.random(), 0.6);
                
                const x = radius * Math.cos(ang);
                const z = radius * Math.sin(ang);

                // 散开位置
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.acos(Math.random() * 2 - 1);
                const r2 = 12 + Math.random() * 6;

                group.userData = {
                    p1: new THREE.Vector3(x, y, z),
                    p2: new THREE.Vector3(r2*Math.sin(theta)*Math.cos(phi), r2*Math.sin(theta)*Math.sin(phi), r2*Math.cos(theta))
                };
                group.position.copy(group.userData.p1);
                masterGroup.add(group);
                particles.push(group);
            }

            // 3. 初始背景雪花
            createSnow();
        }

        function createSnow() {
            const snowCount = 400;
            const snowGeo = new THREE.BufferGeometry();
            const positions = [];
            const speeds = [];

            for (let i = 0; i < snowCount; i++) {
                positions.push((Math.random()-0.5)*100, Math.random()*60-20, (Math.random()-0.5)*100);
                speeds.push(0.05 + Math.random() * 0.1);
            }

            snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.15, transparent: true, opacity: 0.8 });
            const snowSystem = new THREE.Points(snowGeo, snowMat);
            scene.add(snowSystem);
            
            snowParticles = { system: snowSystem, speeds: speeds };
        }

        async function startAuto() {
            initScene();
            const video = document.getElementById('video-input');
            const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });

            hands.onResults(results => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];

                    // 抓握判断
                    const dist = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    toggleState(dist > 0.4);

                    // 旋转控制回归：利用手掌中心(lm[0])位置控制 targetRotation
                    targetRotationY = (lm[0].x - 0.5) * 5;
                    targetRotationX = (lm[0].y - 0.5) * 5;
                }
            });

            new Camera(video, { onFrame: async () => await hands.send({ image: video }), width: 640, height: 480 }).start();

            document.getElementById('loader').style.opacity = '0';
            setTimeout(() => document.getElementById('loader').style.display = 'none', 800);
            animate();
        }

        let isOpened = false;
        function toggleState(open) {
            if (isOpened === open) return;
            isOpened = open;

            document.getElementById('ui-right').innerText = open ? "手掌移动旋转" : "抓握缩放粒子";

            particles.forEach((p) => {
                const target = open ? p.userData.p2 : p.userData.p1;
                gsap.to(p.position, {
                    x: target.x, y: target.y, z: target.z,
                    duration: open ? 0.8 : 0.6,
                    ease: open ? "expo.out" : "back.in(1.2)",
                    delay: Math.random() * 0.1
                });
            });

            if (topper) {
                const t = open ? topper.userData.p2 : topper.userData.p1;
                gsap.to(topper.position, { x: t.x, y: t.y, z: t.z, duration: open ? 0.8 : 0.6, ease: open ? "expo.out" : "back.in(1.2)" });
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            // 1. 雪花飘落逻辑
            const positions = snowParticles.system.geometry.attributes.position.array;
            for (let i = 0; i < positions.length; i += 3) {
                positions[i+1] -= snowParticles.speeds[i/3]; // 向下掉
                positions[i] += Math.sin(Date.now() * 0.001 + i) * 0.02; // 左右晃
                if (positions[i+1] < -30) positions[i+1] = 30; // 循环
            }
            snowParticles.system.geometry.attributes.position.needsUpdate = true;

            // 2. 平滑手势旋转
            currentRotationX += (targetRotationX - currentRotationX) * smoothing;
            currentRotationY += (targetRotationY - currentRotationY) * smoothing;

            if (window.masterGroup) {
                window.masterGroup.rotation.x = currentRotationX;
                window.masterGroup.rotation.y = currentRotationY;
                window.masterGroup.rotation.y += 0.003; // 自动慢转
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = startAuto;
    </script>
</body>
</html>
