<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>Magical Tarot Selection</title>
    <style>
        body { margin: 0; overflow: hidden; background: #0a0a1a; cursor: none; }
        #canvas-container { width: 100vw; height: 100vh; }
        /* 简单遮罩营造氛围 */
        #overlay {
            position: fixed; pointer-events: none;
            top: 0; left: 0; width: 100%; height: 100%;
            background: radial-gradient(circle, transparent 20%, rgba(0,0,0,0.8) 100%);
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>
    <div id="overlay"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>

    <script>
        // --- 初始化场景 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        // --- 核心变量 ---
        let cards = [];
        const cardGroup = new THREE.Group();
        let targetRotY = 0;
        let currentRotY = 0;
        const mouse = new THREE.Vector2();

        // --- 1. 创建梦幻卡牌 ---
        const cardGeometry = new THREE.PlaneGeometry(1, 1.6);
        const cardMaterial = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 } },
            vertexShader: `
                varying vec2 vUv;
                void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
            `,
            fragmentShader: `
                uniform float uTime;
                varying vec2 vUv;
                void main() {
                    vec3 col = vec3(0.9, 0.7, 0.9) + 0.1 * cos(uTime + vUv.xyx + vec3(0,2,4));
                    float star = pow(sin(vUv.x*50.0)*cos(vUv.y*50.0), 20.0);
                    gl_FragColor = vec4(col + star, 1.0);
                }
            `,
            side: THREE.DoubleSide
        });

        for (let i = 0; i < 20; i++) {
            const card = new THREE.Mesh(cardGeometry, cardMaterial.clone());
            const angle = (i / 20) * Math.PI * 2;
            card.position.set(Math.sin(angle) * 4, 0, Math.cos(angle) * 4);
            card.lookAt(0, 0, 0);
            cardGroup.add(card);
            cards.push(card);
        }
        scene.add(cardGroup);
        camera.position.z = 1; // 视角在环绕中心

        // --- 2. 交互逻辑 (模拟手势) ---
        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            // 模拟阻尼滑动的目标速度
            targetRotY = mouse.x * 0.1;
        });

        // --- 3. 渲染循环 ---
        function animate(time) {
            requestAnimationFrame(animate);
            const delta = time * 0.001;

            // 物理阻尼滑动：刹车感
            currentRotY += (targetRotY - currentRotY) * 0.05; 
            cardGroup.rotation.y += currentRotY;

            // 更新所有卡牌 Shader 时间
            cards.forEach(card => {
                card.material.uniforms.uTime.value = delta;
                
                // 模拟射线悬浮效果 (当牌在正前方时向上漂浮)
                const worldPos = new THREE.Vector3();
                card.getWorldPosition(worldPos);
                if(Math.abs(worldPos.z - 4) < 0.5) { // 简易判定卡牌在面前
                    gsap.to(card.position, { y: 0.5, duration: 0.5 });
                } else {
                    gsap.to(card.position, { y: 0, duration: 0.5 });
                }
            });

            renderer.render(scene, camera);
        }
        animate();

        // 响应式调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
