<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Stellar Christmas Core - High Glow</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #video-input { position: absolute; width: 0; height: 0; opacity: 0; pointer-events: none; }
        #ui-right {
            position: fixed; top: 40px; right: 40px; color: #d4af37; font-family: sans-serif; z-index: 100;
            letter-spacing: 2px; font-size: 13px; background: rgba(212, 175, 87, 0.1);
            padding: 10px 20px; border-right: 2px solid #d4af37; backdrop-filter: blur(5px);
            animation: pulse 2s infinite ease-in-out;
        }
        #loader {
            position: fixed; inset: 0; background: #000; display: flex;
            align-items: center; justify-content: center; z-index: 2000;
            color: #d4af37; font-family: serif; letter-spacing: 5px; transition: opacity 0.8s;
        }
        @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
    </style>
</head>
<body>
    <div id="loader">IGNITING RADIANT CORE...</div>
    <div id="ui-right">握拳让树归位正面</div>

    <video id="video-input" autoplay playsinline></video>
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particles = [];
        let targetRotationX = 0, targetRotationY = 0;
        let currentRotationX = 0, currentRotationY = 0;
        const smoothing = 0.08;

        let topper;
        let snowParticles = [];
        let isOpened = false;

        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            // --- 强化发光纹理 ---
            const canvas = document.createElement('canvas');
            canvas.width = 64; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');      // 中心纯白
            grad.addColorStop(0.2, 'rgba(255, 255, 255, 0.8)');   // 核心发散
            grad.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');   // 边缘光晕
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');
            ctx.fillStyle = grad; ctx.fillRect(0, 0, 64, 64);
            const tex = new THREE.CanvasTexture(canvas);

            const masterGroup = new THREE.Group();
            scene.add(masterGroup);
            window.masterGroup = masterGroup;

            const treeHeight = 16;
            const baseRadius = 6.5;
            const yTop = treeHeight * 0.5;
            const yBottom = -treeHeight * 0.5;

            // 1. 顶部超亮黄色粒子
            const topperMat = new THREE.SpriteMaterial({ 
                map: tex, color: 0xfff000, blending: THREE.AdditiveBlending, 
                transparent: true, opacity: 2.0 // 强度加倍
            });
            topper = new THREE.Sprite(topperMat);
            topper.scale.set(4.5, 4.5, 1);
            topper.userData = {
                p1: new THREE.Vector3(0, yTop + 1.5, 0),
                p2: new THREE.Vector3(0, 0, 0)
            };
            topper.position.copy(topper.userData.p1);
            masterGroup.add(topper);

            // 2. 圣诞树身粒子
            for (let i = 0; i < 1500; i++) {
                const group = new THREE.Group();
                const r = Math.random();
                // 提高颜色明度
                let c = (r < 0.85) ? new THREE.Color(0.2, 0.9, 0.3) : 
                        (r < 0.93) ? new THREE.Color(1.0, 0.2, 0.2) : new THREE.Color(1.0, 0.9, 0.4);

                const core = new THREE.Mesh(new THREE.SphereGeometry(0.035), new THREE.MeshBasicMaterial({ color: c }));
                const glow = new THREE.Sprite(new THREE.SpriteMaterial({ 
                    map: tex, color: c, blending: THREE.AdditiveBlending, 
                    transparent: true, opacity: 2.0 // 发光强度加到 2
                }));
                glow.scale.set(0.7, 0.7, 1);
                group.add(core, glow);

                const t = Math.random();
                const y = yBottom + t * treeHeight;
                const yn = (y - yBottom) / treeHeight; 
                const radiusMax = baseRadius * Math.pow(1 - yn, 1.4); 

                const ang = Math.random() * Math.PI * 2;
                const radius = radiusMax * Math.pow(Math.random(), 0.7);
                
                const phi = Math.random() * Math.PI * 2;
                const theta = Math.acos(Math.random() * 2 - 1);
                const r2 = 13 + Math.random() * 5;

                group.userData = {
                    p1: new THREE.Vector3(radius * Math.cos(ang), y, radius * Math.sin(ang)),
                    p2: new THREE.Vector3(r2*Math.sin(theta)*Math.cos(phi), r2*Math.sin(theta)*Math.sin(phi), r2*Math.cos(theta))
                };
                group.position.copy(group.userData.p1);
                masterGroup.add(group);
                particles.push(group);
            }

            createSnow();
        }

        function createSnow() {
            const snowCount = 500;
            const snowGeo = new THREE.BufferGeometry();
            const positions = [];
            const speeds = [];
            for (let i = 0; i < snowCount; i++) {
                positions.push((Math.random()-0.5)*100, Math.random()*60-20, (Math.random()-0.5)*100);
                speeds.push(0.04 + Math.random() * 0.08);
            }
            snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            const snowMat = new THREE.PointsMaterial({ color: 0xffffff, size: 0.12, transparent: true, opacity: 0.8 });
            const snowSystem = new THREE.Points(snowGeo, snowMat);
            scene.add(snowSystem);
            snowParticles = { system: snowSystem, speeds: speeds };
        }

        async function startAuto() {
            initScene();
            const video = document.getElementById('video-input');
            const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });

            hands.onResults(results => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const dist = Math.hypot(lm[8].x - lm[0].x, lm[8].y - lm[0].y);
                    const open = dist > 0.42;
                    
                    toggleState(open);

                    if(open) {
                        targetRotationY = (lm[0].x - 0.5) * 5;
                        targetRotationX = (lm[0].y - 0.5) * 5;
                    } else {
                        targetRotationY = 0;
                        targetRotationX = 0;
                    }
                }
            });

            new Camera(video, { onFrame: async () => await hands.send({ image: video }), width: 640, height: 480 }).start();
            document.getElementById('loader').style.opacity = '0';
            setTimeout(() => document.getElementById('loader').style.display = 'none', 800);
            animate();
        }

        function toggleState(open) {
            if (isOpened === open) return;
            isOpened = open;

            particles.forEach((p) => {
                const target = open ? p.userData.p2 : p.userData.p1;
                gsap.to(p.position, {
                    x: target.x, y: target.y, z: target.z,
                    duration: open ? 0.8 : 0.6,
                    ease: open ? "expo.out" : "back.in(1.2)",
                    delay: Math.random() * 0.1
                });
            });

            if (topper) {
                const t = open ? topper.userData.p2 : topper.userData.p1;
                gsap.to(topper.position, { x: t.x, y: t.y, z: t.z, duration: open ? 0.8 : 0.6, ease: open ? "expo.out" : "back.in(1.2)" });
            }
        }

        function animate() {
            requestAnimationFrame(animate);

            const pos = snowParticles.system.geometry.attributes.position.array;
            for (let i = 0; i < pos.length; i += 3) {
                pos[i+1] -= snowParticles.speeds[i/3];
                if (pos[i+1] < -30) pos[i+1] = 30;
            }
            snowParticles.system.geometry.attributes.position.needsUpdate = true;

            currentRotationX += (targetRotationX - currentRotationX) * smoothing;
            currentRotationY += (targetRotationY - currentRotationY) * smoothing;

            if (window.masterGroup) {
                window.masterGroup.rotation.x = currentRotationX;
                // 优雅的恒定旋转
                window.masterGroup.rotation.y = currentRotationY + (Date.now() * 0.0006);
            }

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = startAuto;
    </script>
</body>
</html>
