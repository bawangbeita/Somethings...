<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GALAXY CHRISTMAS - ç¨³å®šç‰ˆ</title>
    <style>
        :root { --gold: #ffd700; --red: #ff3344; --dark: #000000; }
        body { margin: 0; overflow: hidden; background: var(--dark); font-family: 'Segoe UI', sans-serif; }
        #video-input { position: fixed; bottom: 20px; right: 20px; width: 150px; border: 2px solid var(--gold); border-radius: 12px; transform: scaleX(-1); z-index: 10; opacity: 0.8; }
        #ui-layer { position: fixed; top: 30px; left: 30px; z-index: 100; color: var(--gold); pointer-events: none; }
        .controls { pointer-events: auto; margin-top: 15px; }
        #upload-btn { background: linear-gradient(45deg, #8b0000, var(--red)); color: white; border: 1px solid var(--gold); padding: 12px 24px; cursor: pointer; border-radius: 30px; font-weight: bold; box-shadow: 0 0 15px rgba(255,51,68,0.3); }
        #loading-screen { position: fixed; inset: 0; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; color: var(--gold); }
        .loader { border: 3px solid #111; border-top: 3px solid var(--gold); border-radius: 50%; width: 40px; height: 40px; animation: spin 1s linear infinite; margin-bottom: 20px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        #skip-btn { margin-top: 20px; color: #555; text-decoration: underline; cursor: pointer; pointer-events: auto; font-size: 14px; }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loader"></div>
        <div id="status-text">âœ¨ æ­£åœ¨è¿æ¥é“¶æ²³ä¿¡å·...</div>
        <div id="skip-btn" onclick="startAnyway()">å¦‚æœåŠ è½½è¿‡æ…¢ï¼Œç‚¹å‡»æ­¤å¤„ç›´æ¥è¿›å…¥</div>
    </div>

    <div id="ui-layer">
        <h1 style="margin:0; letter-spacing:3px; text-shadow: 0 0 20px var(--gold);">GALAXY MEMORY</h1>
        <div class="controls">
            <button id="upload-btn" onclick="document.getElementById('file-input').click()">â• ä¸Šä¼ ç…§ç‰‡</button>
            <input type="file" id="file-input" multiple hidden accept="image/*">
        </div>
        <div id="gesture-hint" style="margin-top:15px; font-size:14px; background: rgba(255,215,0,0.1); padding: 8px; border-radius: 5px;">
            ç­‰å¾… AI æ‰‹åŠ¿åˆå§‹åŒ–...
        </div>
    </div>

    <video id="video-input" autoplay playsinline></video>
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script type="module">
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.150.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.150.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.150.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        let scene, camera, renderer, composer, raycaster;
        let photoFrames = [], grabbedPhoto = null;
        const pointer = new THREE.Vector2(-1, -1);

        // å¼ºåˆ¶è¿›å…¥å‡½æ•°æŒ‚è½½åˆ° window
        window.startAnyway = () => {
            document.getElementById('loading-screen').style.display = 'none';
            if(!scene) init();
        };

        async function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 18;

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            // åæœŸå¤„ç†ï¼šå‘å…‰
            const renderPass = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.15; bloomPass.strength = 1.6;
            composer = new EffectComposer(renderer);
            composer.addPass(renderPass);
            composer.addPass(bloomPass);

            raycaster = new THREE.Raycaster();

            // èƒŒæ™¯ï¼šé›ªèŠ±/æ˜Ÿæ˜Ÿ
            const starGeo = new THREE.BufferGeometry();
            const starPos = [];
            for(let i=0; i<3000; i++) starPos.push((Math.random()-0.5)*100,(Math.random()-0.5)*100,(Math.random()-0.5)*100);
            starGeo.setAttribute('position', new THREE.Float32BufferAttribute(starPos, 3));
            scene.add(new THREE.Points(starGeo, new THREE.PointsMaterial({color:0xffffff, size:0.07})));

            // åœ£è¯æ ‘è£…é¥°
            for(let i=0; i<500; i++){
                const h = Math.random()*14-7;
                const r = (7-h)*0.45;
                const angle = Math.random()*Math.PI*2;
                const dot = new THREE.Mesh(
                    new THREE.SphereGeometry(0.12, 8, 8),
                    new THREE.MeshStandardMaterial({
                        color: Math.random()>0.4?0xffd700:0xff3344,
                        emissive: Math.random()>0.4?0xffd700:0x000000,
                        emissiveIntensity: 0.8
                    })
                );
                dot.position.set(Math.cos(angle)*r, h, Math.sin(angle)*r);
                scene.add(dot);
            }
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));

            initAI();
            animate();
            
            // 5ç§’åè‡ªåŠ¨å…³é—­åŠ è½½é¡µï¼ˆå³ä½¿AIæ²¡å¥½ï¼‰
            setTimeout(window.startAnyway, 5000);
        }

        // ç›¸æ¡†ç”Ÿæˆ
        function createPhotoFrame(tex) {
            const group = new THREE.Group();
            const photo = new THREE.Mesh(new THREE.PlaneGeometry(3, 4), new THREE.MeshBasicMaterial({map:tex, side:2}));
            const border = new THREE.Mesh(
                new THREE.BoxGeometry(3.4, 4.4, 0.15),
                new THREE.MeshStandardMaterial({color:0xffd700, metalness:1, roughness:0.2, emissive:0xffd700, emissiveIntensity:0.5})
            );
            border.position.z = -0.1;
            group.add(photo, border);
            group.position.set((Math.random()-0.5)*15, (Math.random()-0.5)*10, (Math.random()-0.5)*5);
            group.userData = { originPos: group.position.clone(), isPhoto: true };
            scene.add(group);
            photoFrames.push(group);
        }

        document.getElementById('file-input').onchange = (e) => {
            const files = Array.from(e.target.files);
            files.forEach(f => {
                const url = URL.createObjectURL(f);
                new THREE.TextureLoader().load(url, tex => createPhotoFrame(tex));
            });
        };

        async function initAI() {
            try {
                const video = document.getElementById('video-input');
                const hands = new window.Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
                hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
                
                hands.onResults(results => {
                    const hint = document.getElementById('gesture-hint');
                    if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                        if(grabbedPhoto) releasePhoto();
                        return;
                    }
                    hint.innerText = "ğŸ–ï¸ æ‰‹åŠ¿å·²è¿æ¥ï¼šæåˆæ‰‹æŒ‡æå–ç…§ç‰‡";
                    const lm = results.multiHandLandmarks[0];
                    pointer.x = -(lm[8].x - 0.5) * 2;
                    pointer.y = -(lm[8].y - 0.5) * 2;
                    
                    const dist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                    if (dist < 0.05) { if(!grabbedPhoto) tryGrab(); } 
                    else { if(grabbedPhoto) releasePhoto(); }
                });

                const cam = new window.Camera(video, { onFrame: async () => await hands.send({image: video}), width: 640, height: 480 });
                await cam.start();
                window.startAnyway(); 
            } catch (e) {
                console.log("AI åˆå§‹åŒ–å¤±è´¥ï¼Œåˆ‡æ¢ä¸ºæ™®é€šæ¨¡å¼");
                window.startAnyway();
            }
        }

        function tryGrab() {
            raycaster.setFromCamera(pointer, camera);
            const hits = raycaster.intersectObjects(photoFrames, true);
            if(hits.length > 0) {
                let p = hits[0].object;
                while(p.parent && !p.userData.isPhoto) p = p.parent;
                grabbedPhoto = p;
                gsap.to(p.position, {x:0, y:0, z:10, duration:0.7, ease:"back.out(1.5)"});
            }
        }

        function releasePhoto() {
            if(!grabbedPhoto) return;
            const pos = grabbedPhoto.userData.originPos;
            gsap.to(grabbedPhoto.position, {x:pos.x, y:pos.y, z:pos.z, duration:0.5});
            grabbedPhoto = null;
        }

        function animate() {
            requestAnimationFrame(animate);
            scene.rotation.y += 0.002;
            composer.render();
        }

        init();
    </script>
</body>
</html>
