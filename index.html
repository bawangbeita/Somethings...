<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI手势圣诞相框：交互银河树</title>
    <style>
        :root { --gold: #ffd700; --red: #ff3344; --dark: #000000; }
        body { margin: 0; overflow: hidden; background: var(--dark); font-family: sans-serif; }
        #video-input { position: fixed; bottom: 20px; right: 20px; width: 150px; border: 2px solid var(--gold); border-radius: 10px; transform: scaleX(-1); z-index: 10; opacity: 0.6; }
        #ui-layer { position: fixed; top: 20px; left: 20px; z-index: 100; color: var(--gold); pointer-events: none; }
        .controls { pointer-events: auto; margin-top: 10px; }
        #upload-btn { background: rgba(255,215,0,0.2); color: var(--gold); border: 1px solid var(--gold); padding: 10px 20px; cursor: pointer; border-radius: 20px; backdrop-filter: blur(5px); font-weight: bold; }
        #gesture-hint { margin-top: 15px; font-size: 14px; color: #fff; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 5px; display: inline-block; border-left: 3px solid var(--red); }
        #loading-screen { position: fixed; inset: 0; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; color: var(--gold); }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div style="font-size: 24px;">✨ 正在加载圣诞魔法...</div>
    </div>

    <div id="ui-layer">
        <h1 style="text-shadow: 0 0 15px var(--gold);">CHRISTMAS MEMORY</h1>
        <div class="controls">
            <button id="upload-btn" onclick="document.getElementById('file-input').click()">上传您的回忆照片</button>
            <input type="file" id="file-input" multiple hidden accept="image/*">
        </div>
        <div id="gesture-hint">提示：食指指尖靠近照片 -> 捏合手指提起照片</div>
    </div>

    <video id="video-input" autoplay playsinline></video>
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script type="module">
        import { EffectComposer } from 'https://cdn.skypack.dev/three@0.150.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.skypack.dev/three@0.150.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.skypack.dev/three@0.150.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        let scene, camera, renderer, composer, hands, raycaster;
        let treeElements = [], photoFrames = [];
        let grabbedPhoto = null;
        let hoveredPhoto = null;

        const pointer = new THREE.Vector2(-1, -1); // 模拟食指位置

        function init() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 15);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.getElementById('container').appendChild(renderer.domElement);

            raycaster = new THREE.Raycaster();

            // 辉光
            const renderScene = new RenderPass(scene, camera);
            const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
            bloomPass.threshold = 0.1; bloomPass.strength = 1.8;
            composer = new EffectComposer(renderer);
            composer.addPass(renderScene);
            composer.addPass(bloomPass);

            createStars();
            createTreeParticles();
            initAI();
            animate();
            
            document.getElementById('loading-screen').style.display = 'none';
        }

        // 星空背景
        function createStars() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for (let i = 0; i < 2000; i++) pos.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            scene.add(new THREE.Points(geo, new THREE.PointsMaterial({color: 0xffffff, size: 0.05})));
        }

        // 圣诞树装饰粒子
        function createTreeParticles() {
            for (let i = 0; i < 600; i++) {
                const h = Math.random() * 12 - 6;
                const r = (6 - h) * 0.4;
                const angle = Math.random() * Math.PI * 2;
                const mesh = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 8, 8),
                    new THREE.MeshStandardMaterial({ 
                        color: Math.random() > 0.5 ? 0xffd700 : 0xff3344,
                        emissive: Math.random() > 0.5 ? 0xffd700 : 0x000000,
                        emissiveIntensity: 1
                    })
                );
                mesh.position.set(Math.cos(angle)*r, h, Math.sin(angle)*r);
                scene.add(mesh);
            }
        }

        // --- 核心：创建圣诞相框 ---
        function createChristmasFrame(texture) {
            const group = new THREE.Group();
            
            // 1. 照片本身
            const photo = new THREE.Mesh(
                new THREE.PlaneGeometry(3, 4),
                new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide })
            );
            
            // 2. 圣诞感外框 (金边)
            const frameGeo = new THREE.BoxGeometry(3.3, 4.3, 0.1);
            const frameMat = new THREE.MeshStandardMaterial({ 
                color: 0xffd700, metalness: 1, roughness: 0.2,
                emissive: 0xffd700, emissiveIntensity: 0.5 
            });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            frame.position.z = -0.1;

            // 3. 装饰红边
            const innerFrame = new THREE.Mesh(
                new THREE.PlaneGeometry(3.1, 4.1),
                new THREE.MeshBasicMaterial({ color: 0xc41e3a })
            );
            innerFrame.position.z = -0.05;

            group.add(photo, frame, innerFrame);
            
            // 初始随机分布在树周围
            group.position.set((Math.random()-0.5)*10, (Math.random()-0.5)*8, (Math.random()-0.5)*5);
            group.userData.originPos = group.position.clone();
            group.userData.isPhoto = true;
            
            scene.add(group);
            photoFrames.push(group);
        }

        document.getElementById('file-input').onchange = (e) => {
            const files = Array.from(e.target.files);
            files.forEach(file => {
                const url = URL.createObjectURL(file);
                new THREE.TextureLoader().load(url, tex => createChristmasFrame(tex));
            });
        };

        function initAI() {
            const video = document.getElementById('video-input');
            hands = new Hands({ locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.8 });
            
            hands.onResults(results => {
                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                    pointer.set(-1, -1);
                    if (grabbedPhoto) releasePhoto();
                    return;
                }
                
                const lm = results.multiHandLandmarks[0];
                const indexTip = lm[8]; // 食指
                const thumbTip = lm[4]; // 拇指
                
                // 转换坐标用于 Raycaster
                pointer.x = -(indexTip.x - 0.5) * 2;
                pointer.y = -(indexTip.y - 0.5) * 2;

                // 检测捏合 (食指和拇指距离)
                const distance = Math.hypot(indexTip.x - thumbTip.x, indexTip.y - thumbTip.y);
                const isPinching = distance < 0.05;

                updateInteraction(isPinching);
            });

            const cameraHelper = new Camera(video, {
                onFrame: async () => { await hands.send({image: video}); },
                width: 640, height: 480
            });
            cameraHelper.start();
        }

        function updateInteraction(isPinching) {
            raycaster.setFromCamera(pointer, camera);
            const intersects = raycaster.intersectObjects(photoFrames, true);

            if (intersects.length > 0) {
                let target = intersects[0].object;
                while (target.parent && !target.userData.isPhoto) target = target.parent;

                // 悬停闪烁效果
                if (hoveredPhoto && hoveredPhoto !== target) resetPulse(hoveredPhoto);
                hoveredPhoto = target;
                pulsePhoto(hoveredPhoto);

                // 捏合提起
                if (isPinching && !grabbedPhoto) {
                    grabPhoto(target);
                }
            } else {
                if (hoveredPhoto) resetPulse(hoveredPhoto);
                hoveredPhoto = null;
            }

            // 如果松开手指
            if (!isPinching && grabbedPhoto) {
                releasePhoto();
            }
        }

        function pulsePhoto(obj) {
            const frame = obj.children[1];
            frame.material.emissiveIntensity = 2 + Math.sin(Date.now() * 0.01) * 1.5;
        }

        function resetPulse(obj) {
            if(!obj) return;
            obj.children[1].material.emissiveIntensity = 0.5;
        }

        function grabPhoto(obj) {
            grabbedPhoto = obj;
            gsap.to(obj.position, { x: 0, y: 0, z: 8, duration: 0.8, ease: "back.out(1.7)" });
            gsap.to(obj.rotation, { y: Math.PI * 2, duration: 0.8 });
            document.getElementById('gesture-hint').innerText = "✨ 提起成功！正在放大回忆...";
        }

        function releasePhoto() {
            const origin = grabbedPhoto.userData.originPos;
            gsap.to(grabbedPhoto.position, { x: origin.x, y: origin.y, z: origin.z, duration: 0.6, ease: "power2.inOut" });
            gsap.to(grabbedPhoto.rotation, { y: 0, duration: 0.6 });
            grabbedPhoto = null;
            document.getElementById('gesture-hint').innerText = "提示：食指指尖靠近照片 -> 捏合手指提起照片";
        }

        function animate() {
            requestAnimationFrame(animate);
            // 场景微动
            scene.rotation.y += 0.002;
            composer.render();
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        init();
    </script>
</body>
</html>
