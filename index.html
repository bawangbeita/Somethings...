<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Soft Magic Stellar Core</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #video-input { position: absolute; width: 0; height: 0; opacity: 0; pointer-events: none; }
        #ui-left { position: fixed; top: 40px; left: 40px; color: #d4af37; font-family: 'Optima', serif; z-index: 100; pointer-events: none; letter-spacing: 4px; }
        #ui-right { 
            position: fixed; top: 40px; right: 40px; color: #d4af37; font-family: sans-serif; z-index: 100; 
            letter-spacing: 2px; font-size: 13px; background: rgba(212, 175, 87, 0.1);
            padding: 10px 20px; border-right: 2px solid #d4af37; backdrop-filter: blur(5px);
            animation: pulse 2s infinite ease-in-out;
        }
        #loader { 
            position: fixed; inset: 0; background: #000; display: flex; 
            align-items: center; justify-content: center; z-index: 2000; 
            color: #d4af37; font-family: serif; letter-spacing: 5px; transition: opacity 0.8s;
        }
        @keyframes pulse { 0%, 100% { opacity: 0.5; } 50% { opacity: 1; } }
    </style>
</head>
<body>

    <div id="loader">IGNITING...</div>
    <div id="ui-right">在镜头前移动手掌试试看！</div>

    <video id="video-input" autoplay playsinline></video>
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script>
        let scene, camera, renderer, particles = [];
        let targetRotationX = 0, targetRotationY = 0;
        let currentRotationX = 0, currentRotationY = 0;
        const smoothing = 0.08;
        let isOpened = false;

        function initScene() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 50;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            document.getElementById('container').appendChild(renderer.domElement);

            // --- 柔和光晕纹理优化 ---
            const canvas = document.createElement('canvas');
            canvas.width = 64; // 增加分辨率让边缘更平滑
            canvas.height = 64;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');      // 中心纯白
            grad.addColorStop(0.1, 'rgba(212, 175, 55, 0.6)');    // 核心金色
            grad.addColorStop(0.4, 'rgba(212, 175, 55, 0.15)');   // 中间过渡（更淡）
            grad.addColorStop(1, 'rgba(0, 0, 0, 0)');              // 边缘完全透明（无硬边）
            
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 64, 64);
            const tex = new THREE.CanvasTexture(canvas);

            const masterGroup = new THREE.Group();
            scene.add(masterGroup);
            window.masterGroup = masterGroup;

            const treeHeight = 14;
            const baseRadius = 6.0;
            const yBottom = -treeHeight * 0.5;
            const yTop = treeHeight * 0.5;

            // 创建顶部的发光粒子
            const topperMaterial = new THREE.MeshStandardMaterial({
                color: new THREE.Color(1, 0.84, 0), // 黄金色
                emissive: new THREE.Color(1, 0.84, 0), // 光芒发射
                emissiveIntensity: 2, // 光芒强度
                metalness: 1, // 金属感
                roughness: 0.2 // 光泽度
            });

            const topper = new THREE.Mesh(new THREE.SphereGeometry(0.6), topperMaterial); // 增加顶部粒子的大小
            topper.position.set(0, yTop + 1.5, 0); // 调整顶部粒子位置
            masterGroup.add(topper);

            // 创建其他粒子
            for (let i = 0; i < 1500; i++) {
                const group = new THREE.Group();
                const core = new THREE.Mesh(new THREE.SphereGeometry(0.035), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                const glow = new THREE.Sprite(new THREE.SpriteMaterial({
                    map: tex, 
                    blending: THREE.AdditiveBlending, 
                    transparent: true, 
                    opacity: 1.0 // 增加亮度
                }));
                glow.scale.set(0.6, 0.6, 1); // 稍微放大光晕范围
                group.add(core, glow);

                const phi = Math.random() * Math.PI * 2, theta = Math.acos(Math.random() * 2 - 1);
                const r1 = 4.5 * Math.pow(Math.random(), 3.5);
                const r2 = 12 + Math.random() * 5;

                group.userData = {
                    p1: new THREE.Vector3(r1 * Math.sin(theta) * Math.cos(phi), r1 * Math.sin(theta) * Math.sin(phi), r1 * Math.cos(theta)),
                    p2: new THREE.Vector3(r2 * Math.sin(theta) * Math.cos(phi), r2 * Math.sin(theta) * Math.sin(phi), r2 * Math.cos(theta))
                };
                group.position.copy(group.userData.p1);
                masterGroup.add(group);
                particles.push(group);
            }
        }

        async function startAuto() {
            initScene();
            const video = document.getElementById('video-input');
            const hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });

            hands.onResults(results => {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];

                    // 计算手指之间的距离，判断手掌是否张开
                    const thumbDist = Math.hypot(lm[4].x - lm[0].x, lm[4].y - lm[0].y);
                    const indexDist = Math.hypot(lm[8].x - lm[5].x, lm[8].y - lm[5].y);
                    const middleDist = Math.hypot(lm[12].x - lm[9].x, lm[12].y - lm[9].y);
                    const ringDist = Math.hypot(lm[16].x - lm[13].x, lm[16].y - lm[13].y);
                    const pinkyDist = Math.hypot(lm[20].x - lm[17].x, lm[20].y - lm[17].y);

                    const isHandOpen = thumbDist > 0.1 && indexDist > 0.1 && middleDist > 0.1 && ringDist > 0.1 && pinkyDist > 0.1;
                    
                    // 根据手势的张开情况来改变粒子状态
                    toggleState(isHandOpen);

                    // 更新旋转角度
                    targetRotationY = (lm[0].x - 0.5) * 4;
                    targetRotationX = (lm[0].y - 0.5) * 4;
                }
            });

            const cameraHelper = new Camera(video, {
                onFrame: async () => await hands.send({ image: video }),
                width: 640, height: 480
            });

            try {
                await cameraHelper.start();
                document.getElementById('loader').style.opacity = '0';
                setTimeout(() => document.getElementById('loader').style.display = 'none', 800);
                animate();
            } catch (e) {
                document.getElementById('loader').innerText = "CAMERA ERROR";
            }
        }

        function toggleState(open) {
            if (isOpened === open) return;
            isOpened = open;

            // 切换文字内容
            const uiRight = document.getElementById('ui-right');
            if (open) {
                uiRight.innerText = "在镜头前移动手掌试试看！"; // 扩散时显示新的文字
            } else {
                uiRight.innerText = "在镜头前抓握试试看！"; // 粒子回缩时恢复原文字
            }

            // 动画效果
            particles.forEach((p, i) => {
                const target = open ? p.userData.p2 : p.userData.p1;
                gsap.to(p.position, {
                    x: target.x, y: target.y, z: target.z,
                    duration: open ? 0.8 : 0.6, 
                    ease: open ? "expo.out" : "back.in(1.2)", 
                    delay: Math.random() * 0.15 
                });
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            currentRotationX += (targetRotationX - currentRotationX) * smoothing;
            currentRotationY += (targetRotationY - currentRotationY) * smoothing;
            if(window.masterGroup) {
                window.masterGroup.rotation.x = currentRotationX;
                window.masterGroup.rotation.y = currentRotationY;
                window.masterGroup.rotation.z += 0.002; // 缓慢自转
            }
            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        window.onload = startAuto;
    </script>
</body>
</html>