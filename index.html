<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
    <title>Lite Christmas Tree - Mobile</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; touch-action: none; }
        #loader {
            position: fixed; inset: 0; background: #000; display: flex;
            align-items: center; justify-content: center; z-index: 2000;
            color: #d4af37; font-family: sans-serif; letter-spacing: 2px;
        }
        #video-input { position: absolute; width: 1px; height: 1px; opacity: 0; }
        #hint {
            position: fixed; bottom: 20px; width: 100%; text-align: center;
            color: rgba(212, 175, 87, 0.7); font-size: 12px; z-index: 100;
        }
    </style>
</head>
<body>

<div id="loader">âœ¨ æ­£åœ¨å¬å”¤ç§»åŠ¨ç«¯é­”æ³•...</div>
<div id="hint">ğŸ–ï¸ å¼ å¼€çˆ†ç‚¸ | âœŠ æ¡æ‹³èšæ‹¢æ ‘</div>
<video id="video-input" playsinline></video>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/gsap@3.12.2/dist/gsap.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

<script>
    let scene, camera, renderer, particles, star;
    const particleCount = 1200; // ç§»åŠ¨ç«¯ä¼˜åŒ–åçš„æ•°é‡
    let handReady = false;
    let mode = 'TREE'; // TREE or BURST

    // --- åˆ›å»ºå‘å…‰ç²’å­è´´å›¾ (æ ¸å¿ƒä¼˜åŒ–ï¼šç”¨è´´å›¾ä»£æ›¿æ»¤é•œ) ---
    function createGlowTexture() {
        const canvas = document.createElement('canvas');
        canvas.width = 64; canvas.height = 64;
        const ctx = canvas.getContext('2d');
        const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
        gradient.addColorStop(0, 'rgba(255,255,255,1)');
        gradient.addColorStop(0.2, 'rgba(255,230,150,0.8)');
        gradient.addColorStop(0.5, 'rgba(255,100,0,0.3)');
        gradient.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, 64, 64);
        return new THREE.CanvasTexture(canvas);
    }

    async function init() {
        scene = new THREE.Scene();
        camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 5;

        renderer = new THREE.WebGLRenderer({ antialias: false, precision: 'lowp' });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 1.5)); // é™åˆ¶åƒç´ æ¯”
        document.body.appendChild(renderer.domElement);

        // 1. åˆ›å»ºç²’å­ç³»ç»Ÿ
        const geo = new THREE.BufferGeometry();
        const pos = new Float32Array(particleCount * 3);
        const targetPos = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);

        for (let i = 0; i < particleCount; i++) {
            // åˆå§‹éšæœºä½ç½®
            pos[i*3] = (Math.random()-0.5)*10;
            pos[i*3+1] = (Math.random()-0.5)*10;
            pos[i*3+2] = (Math.random()-0.5)*10;

            // è®¡ç®—æ ‘å½¢ç›®æ ‡ä½ç½® (åœ†é”¥åˆ†å¸ƒ)
            const h = Math.random(); 
            const radius = (1 - h) * 1.5;
            const theta = Math.random() * Math.PI * 2;
            targetPos[i*3] = Math.cos(theta) * radius * Math.pow(Math.random(), 0.5);
            targetPos[i*3+1] = h * 3 - 1.5;
            targetPos[i*3+2] = Math.sin(theta) * radius * Math.pow(Math.random(), 0.5);

            // é¢œè‰²ï¼šåœ£è¯ç»¿/é‡‘
            colors[i*3] = 0.8 + Math.random()*0.2;
            colors[i*3+1] = 0.4 + Math.random()*0.5;
            colors[i*3+2] = 0.2;
        }

        geo.setAttribute('position', new THREE.BufferAttribute(pos, 3));
        geo.setAttribute('color', new THREE.BufferAttribute(colors, 3));
        
        const mat = new THREE.PointsMaterial({
            size: 0.12,
            map: createGlowTexture(),
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            vertexColors: true
        });

        particles = new THREE.Points(geo, mat);
        scene.add(particles);

        // 2. é¡¶éƒ¨æ˜Ÿæ˜Ÿ
        const starGeo = new THREE.SphereGeometry(0.15, 8, 8);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xfff000 });
        star = new THREE.Mesh(starGeo, starMat);
        star.position.y = 1.6;
        scene.add(star);

        // 3. å¯åŠ¨æ‰‹åŠ¿è¯†åˆ« (Liteç‰ˆæœ¬)
        initMediaPipe();
        
        animate();
        window.addEventListener('resize', onWindowResize);
    }

    function initMediaPipe() {
        const videoElement = document.getElementById('video-input');
        const hands = new Hands({
            locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 0, // å…³é”®ï¼šé™ä½æ¨¡å‹å¤æ‚åº¦æå‡ç§»åŠ¨ç«¯å¸§ç‡
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const cameraFeed = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 480, height: 480
        });
        cameraFeed.start().then(() => {
            document.getElementById('loader').style.opacity = 0;
            setTimeout(() => document.getElementById('loader').remove(), 800);
        });
    }

    function onResults(results) {
        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            // ç®€å•é€»è¾‘ï¼šé€šè¿‡é£ŸæŒ‡å°–å’Œæ‰‹æŒä¸­å¿ƒè·ç¦»åˆ¤æ–­æ¡æ‹³/å¼ å¼€
            const dist = Math.hypot(landmarks[8].x - landmarks[0].x, landmarks[8].y - landmarks[0].y);
            
            if (dist > 0.4) {
                if(mode !== 'BURST') burstEffect();
            } else {
                if(mode !== 'TREE') treeEffect();
            }
        }
    }

    function treeEffect() {
        mode = 'TREE';
        const posAttr = particles.geometry.attributes.position;
        // ä½¿ç”¨GSAPå¹³æ»‘è¿‡æ¸¡åˆ°æ ‘å½¢
        // è¿™é‡Œä¸ºäº†æ¼”ç¤ºç®€åŒ–ï¼Œå®é™…åº”ç”¨ä¸­å¯ç”¨æ›´å¤æ‚çš„Tween
        gsap.to(particles.rotation, { y: Math.PI * 2, duration: 2 });
    }

    function burstEffect() {
        mode = 'BURST';
        // éšæœºå‘å¤–å¼¹å°„
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function animate() {
        requestAnimationFrame(animate);
        particles.rotation.y += 0.005;
        // æ¨¡æ‹Ÿç²’å­å‘¼å¸æ„Ÿ
        particles.material.size = 0.1 + Math.sin(Date.now() * 0.002) * 0.03;
        renderer.render(scene, camera);
    }

    init();
</script>
</body>
</html>
