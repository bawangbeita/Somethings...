<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI手势圣诞：稳定版</title>
    <style>
        :root { --gold: #ffd700; --red: #ff3344; --dark: #000000; }
        body { margin: 0; overflow: hidden; background: var(--dark); font-family: sans-serif; }
        #video-input { position: fixed; bottom: 20px; right: 20px; width: 140px; border: 1px solid var(--gold); border-radius: 8px; transform: scaleX(-1); z-index: 10; opacity: 0.5; }
        #ui-layer { position: fixed; top: 20px; left: 20px; z-index: 100; color: var(--gold); pointer-events: none; }
        .controls { pointer-events: auto; margin-top: 10px; }
        #upload-btn { background: rgba(255,215,0,0.2); color: var(--gold); border: 1px solid var(--gold); padding: 10px 20px; cursor: pointer; border-radius: 20px; backdrop-filter: blur(5px); }
        #loading-screen { position: fixed; inset: 0; background: #000; display: flex; flex-direction: column; align-items: center; justify-content: center; z-index: 1000; color: var(--gold); }
        .loader { border: 2px solid #333; border-top: 2px solid var(--gold); border-radius: 50%; width: 30px; height: 30px; animation: spin 1s linear infinite; margin-bottom: 10px; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>
</head>
<body>

    <div id="loading-screen">
        <div class="loader"></div>
        <div id="load-status">✨ 正在召唤银河星尘...</div>
    </div>

    <div id="ui-layer">
        <h1 style="text-shadow: 0 0 15px var(--gold);">GALAXY MEMORY</h1>
        <div class="controls">
            <button id="upload-btn" onclick="document.getElementById('file-input').click()">上传照片</button>
            <input type="file" id="file-input" multiple hidden accept="image/*">
        </div>
        <div id="gesture-hint" style="margin-top:10px; font-size:12px; border-left:2px solid var(--red); padding-left:10px;">
            等待相机开启...
        </div>
    </div>

    <video id="video-input" autoplay playsinline></video>
    <div id="container"></div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/gsap@3.11.4/dist/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script type="module">
        // 从同一个稳定的 CDN 导入后期处理组件
        import { EffectComposer } from 'https://cdn.jsdelivr.net/npm/three@0.150.0/examples/jsm/postprocessing/EffectComposer.js';
        import { RenderPass } from 'https://cdn.jsdelivr.net/npm/three@0.150.0/examples/jsm/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'https://cdn.jsdelivr.net/npm/three@0.150.0/examples/jsm/postprocessing/UnrealBloomPass.js';

        let scene, camera, renderer, composer, hands, raycaster;
        let photoFrames = [], grabbedPhoto = null;
        const pointer = new THREE.Vector2(-1, -1);

        // 初始化
        async function init() {
            try {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
                camera.position.z = 15;

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
                document.getElementById('container').appendChild(renderer.domElement);

                // 辉光效果
                composer = new EffectComposer(renderer);
                composer.addPass(new RenderPass(scene, camera));
                const bloom = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.5, 0.4, 0.85);
                bloom.threshold = 0.1; bloom.strength = 1.5; 
                composer.addPass(bloom);

                raycaster = new THREE.Raycaster();

                createGalaxy();
                createDecoration();
                
                // 启动 AI
                await initAI();
                
                // 隐藏加载页
                document.getElementById('loading-screen').style.display = 'none';
                animate();
            } catch (e) {
                console.error(e);
                document.getElementById('load-status').innerText = "加载失败，请刷新重试";
            }
        }

        function createGalaxy() {
            const geo = new THREE.BufferGeometry();
            const pos = [];
            for (let i = 0; i < 2000; i++) pos.push((Math.random()-0.5)*100, (Math.random()-0.5)*100, (Math.random()-0.5)*100);
            geo.setAttribute('position', new THREE.Float32BufferAttribute(pos, 3));
            scene.add(new THREE.Points(geo, new THREE.PointsMaterial({color: 0xffffff, size: 0.05})));
        }

        function createDecoration() {
            for (let i = 0; i < 400; i++) {
                const h = Math.random() * 12 - 6;
                const r = (6 - h) * 0.4;
                const angle = Math.random() * Math.PI * 2;
                const m = new THREE.Mesh(
                    new THREE.SphereGeometry(0.1, 8, 8),
                    new THREE.MeshStandardMaterial({ color: Math.random() > 0.5 ? 0xffd700 : 0xc41e3a, emissive: 0xffd700, emissiveIntensity: 0.5 })
                );
                m.position.set(Math.cos(angle)*r, h, Math.sin(angle)*r);
                scene.add(m);
            }
            const light = new THREE.PointLight(0xffffff, 1);
            light.position.set(5,5,5);
            scene.add(light, new THREE.AmbientLight(0xffffff, 0.5));
        }

        // 相框生成器
        function createFrame(tex) {
            const group = new THREE.Group();
            const photo = new THREE.Mesh(new THREE.PlaneGeometry(3, 4), new THREE.MeshBasicMaterial({ map: tex, side: 2 }));
            const frame = new THREE.Mesh(new THREE.BoxGeometry(3.3, 4.3, 0.1), new THREE.MeshStandardMaterial({ color: 0xffd700, metalness: 1, roughness: 0.2 }));
            frame.position.z = -0.1;
            group.add(photo, frame);
            group.position.set((Math.random()-0.5)*12, (Math.random()-0.5)*8, (Math.random()-0.5)*5);
            group.userData.originPos = group.position.clone();
            group.userData.isPhoto = true;
            scene.add(group);
            photoFrames.push(group);
        }

        document.getElementById('file-input').onchange = (e) => {
            const files = Array.from(e.target.files);
            files.forEach(file => {
                const url = URL.createObjectURL(file);
                new THREE.TextureLoader().load(url, tex => createFrame(tex));
            });
        };

        async function initAI() {
            const video = document.getElementById('video-input');
            hands = new Hands({ locateFile: (f) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}` });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7 });
            
            hands.onResults(results => {
                const hint = document.getElementById('gesture-hint');
                if (!results.multiHandLandmarks || results.multiHandLandmarks.length === 0) {
                    if(grabbedPhoto) release();
                    return;
                }
                hint.innerText = "✨ AI 已就绪：捏合手指提取照片";
                const lm = results.multiHandLandmarks[0];
                pointer.x = -(lm[8].x - 0.5) * 2;
                pointer.y = -(lm[8].y - 0.5) * 2;
                
                const dist = Math.hypot(lm[8].x - lm[4].x, lm[8].y - lm[4].y);
                if (dist < 0.05) {
                    if(!grabbedPhoto) checkGrab();
                } else {
                    if(grabbedPhoto) release();
                }
            });

            const cam = new Camera(video, { onFrame: async () => await hands.send({image: video}), width: 640, height: 480 });
            return cam.start();
        }

        function checkGrab() {
            raycaster.setFromCamera(pointer, camera);
            const inter = raycaster.intersectObjects(photoFrames, true);
            if(inter.length > 0) {
                let t = inter[0].object;
                while(t.parent && !t.userData.isPhoto) t = t.parent;
                grabbedPhoto = t;
                gsap.to(t.position, { x: 0, y: 0, z: 8, duration: 0.6 });
            }
        }

        function release() {
            if(!grabbedPhoto) return;
            const o = grabbedPhoto.userData.originPos;
            gsap.to(grabbedPhoto.position, { x: o.x, y: o.y, z: o.z, duration: 0.5 });
            grabbedPhoto = null;
        }

        function animate() {
            requestAnimationFrame(animate);
            scene.rotation.y += 0.001;
            composer.render();
        }

        init();
    </script>
</body>
</html>
