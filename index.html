<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <title>魔卡少女樱 - 手势塔罗选牌</title>
    <style>
        body { margin: 0; overflow: hidden; background: #050510; }
        canvas { display: block; }
        #video-container {
            position: fixed; bottom: 10px; right: 10px;
            width: 160px; height: 120px; border: 2px solid rgba(255,192,203,0.5);
            border-radius: 8px; transform: scaleX(-1); /* 镜像画面 */
        }
        #loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: pink; font-family: "Microsoft YaHei", sans-serif; text-align: center;
        }
    </style>
</head>
<body>

    <div id="loading">正在唤醒魔法阵...<br>(请允许开启摄像头)</div>
    <video id="input_video" style="display:none"></video>
    <canvas id="video-container"></canvas>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.7.1/gsap.min.js"></script>

    <script>
        // --- 1. Three.js 场景初始化 ---
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 环境光与魔法光晕
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const cardGroup = new THREE.Group();
        scene.add(cardGroup);

        // --- 2. 梦幻卡牌材质 (Shader) ---
        const cardShaderMaterial = new THREE.ShaderMaterial({
            uniforms: { uTime: { value: 0 } },
            vertexShader: `
                varying vec2 vUv;
                void main() { vUv = uv; gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0); }
            `,
            fragmentShader: `
                uniform float uTime;
                varying vec2 vUv;
                void main() {
                    vec3 pink = vec3(1.0, 0.75, 0.85);
                    vec3 purple = vec3(0.8, 0.6, 1.0);
                    float flow = sin(vUv.x * 5.0 + uTime * 2.0) * 0.5 + 0.5;
                    vec3 base = mix(pink, purple, flow);
                    float star = pow(sin(vUv.x * 30.0 + uTime) * cos(vUv.y * 30.0), 20.0);
                    gl_FragColor = vec4(base + star, 1.0);
                }
            `,
            side: THREE.DoubleSide
        });

        const cards = [];
        const cardCount = 22;
        const radius = 6;

        for (let i = 0; i < cardCount; i++) {
            const geo = new THREE.PlaneGeometry(1.2, 2);
            const card = new THREE.Mesh(geo, cardShaderMaterial.clone());
            const angle = (i / cardCount) * Math.PI * 2;
            card.position.set(Math.sin(angle) * radius, 0, Math.cos(angle) * radius);
            card.lookAt(0, 0, 0); // 背面朝内，人站在中间
            cardGroup.add(card);
            cards.push(card);
        }

        camera.position.set(0, 0, 0.1); // 相机放在圆心

        // 指尖发光粒子
        const fingerGlow = new THREE.Mesh(
            new THREE.SphereGeometry(0.1, 16, 16),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 })
        );
        scene.add(fingerGlow);

        // --- 3. 物理变量 ---
        let targetVelocity = 0;
        let currentVelocity = 0;
        const raycaster = new THREE.Raycaster();

        // --- 4. MediaPipe 手势逻辑 ---
        const videoElement = document.getElementById('input_video');
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});

        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });

        hands.onResults((results) => {
            document.getElementById('loading').style.display = 'none';
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                const palm = hand[9];   // 手掌
                const index = hand[8]; // 食指

                // 左右滑动：映射 X 到速度
                targetVelocity = (palm.x - 0.5) * -0.25;

                // 指尖粒子跟随 (NDC 坐标转换)
                const x = (index.x * 2 - 1);
                const y = -(index.y * 2 - 1);
                fingerGlow.position.set(x * 5, y * 3, -4); // 投影到 3D 平面

                // 悬浮判定
                raycaster.setFromCamera(new THREE.Vector2(x, y), camera);
                const intersects = raycaster.intersectObjects(cards);
                if (intersects.length > 0) {
                    gsap.to(intersects[0].object.position, { y: 0.5, duration: 0.3 });
                } else {
                    cards.forEach(c => gsap.to(c.position, { y: 0, duration: 0.5 }));
                }
            } else {
                targetVelocity = 0; // 手离开，进入刹车
            }
        });

        const cameraCtx = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 480, height: 360
        });
        cameraCtx.start();

        // --- 5. 动画循环 ---
        function animate(time) {
            requestAnimationFrame(animate);
            const t = time * 0.001;

            // 阻尼感滑动
            currentVelocity += (targetVelocity - currentVelocity) * 0.05;
            cardGroup.rotation.y += currentVelocity;

            // 刹车感：微小速度直接归零
            if (Math.abs(currentVelocity) < 0.0001) currentVelocity = 0;

            // 更新 Shader
            cards.forEach(c => c.material.uniforms.uTime.value = t);

            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
